#+TITLE: Experiment Guide for UNIX Network Programming
#+DATE: <2021-03-23 Tue>
#+AUTHOR: 网182陈涛 and 189074308

* Remark

1. You should submit the HTML file of this file, using C-c C-e h h.
2. the HTML file name should be of the form: UNP2020-189074308.html

* Exp. 1st: A one-time shell "system"

** README
   Please implement a shell command, whose name is system. 
   When executed, it requires another command as 
   its argument, and this command could be composed by one or multiple 
   arguments. For instance, "system" may be executed as follows:

#+BEGIN_SRC sh
  usr@~/>./system cat text.txt
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
int main(int argc, char *argv[])
{
	char buffer[BUFSIZ + 1];
	char file_des[2];
	pid_t cpid;
	char somed_ata[2];
	int flag = 0;
	memset(buffer, '\0', sizeof(buffer));
	if (argc == 3)
	{
		if (strcmp(argv[1], "cat") == 0)
		{
			flag = 0;
		}
		else
		{
			flag = 1;
		}
		if (flag == 0)
		{
			cpid = fork();
			if (cpid == -1) //Creat Error
			{
				exit(0);
			}
			else if (cpid == 0) //Creat Child
			{
				write(file_des[1], argv, strlen(argv));
			}
			else //Creat Father
			{
				sprintf(buffer, "%s", file_des[0]);
				execvp("cat",buffer);
			}
		}
		else
		{
			exit(0);
		}
	}
	else
	{
		exit(0);
	}
}
#+END_SRC

   The command "system", implemented by you, should act like as a one-time 
   shell to execute its argument "cat text.txt". Specifically, it should
   at first fork a child process, between which and itself there has been 
   a pipe. The child process duplicates its stdout (and its stderr) to the
   write end of the pipe, with which it can transfer the output to the parent,
   and then call some function in the "exec" family to execute the command "cat" 
   with the argument "text.txt", for instance. On the other side of the pipe,
   the parent should read from the read end of the pipe to receive the output
   of the child, and print them on the displayer. After the termination of the
   child, the parent should reap it, and then exit.
   
** The code
#+BEGIN_SRC C
/* Your code here */
#+END_SRC 


* Exp. 2nd: Concurrent Echo Service by TCP

** README
  In this experiment, you should implement a pair of client-server programs. The server program
  provides Echo service with concurrent child processes. For each client request, the parent
  server, which is responsible for listening, will fork a child process to deal with the request.
  The child process exits after the completion of the service, and it will reaped by the parent
  through signal handling (using system API sigaction ).

  The client initiates the request by the following command:

#+BEGIN_SRC sh
unix> ./echoclient <server's IP> < file.txt
line 1    # data echoed back by the server
line 2
line 3
...
unix>
#+END_SRC

** The code
  
#+BEGIN_SRC C
/* Client code here */
#+END_SRC 

#+BEGIN_SRC C
/* Server code here */
#+END_SRC 

* Exp. 3rd: IO-Multiplexing
  
** README
  Use the system API "epoll" to implement the server program in the 
  second experiment.

** The code
#+BEGIN_SRC c
  /* server code here */
#+END_SRC 

* Exp. 4th: Pre-allocated Threading with Mutex

** README
  In this experiment, you will implement a TCP-based echo server with
  pre-allocated threading. Threads use POSIX thread mutex to multuall exclusively call
  the "accept" to establish the connection. 

  You can use clients in Exp. 2nd to test your code.
** The code

#+BEGIN_SRC C

#+END_SRC

* Exp. 5th: Pre-allocated Process Server

** README

  In this experiment, your job is to implement a pre-allocated process server.
  Before calling the API accept on the listening socket, the socket descriptor
  should be set as a reusable one such that it can be listened simultaneously by multiple
  processes (use the socket option SO_ REUSEPORT). You do not need to worry
  about "thunder herd".

  You can use clients in Exp. 2nd to test your code.

** The code
#+BEGIN_SRC C

#+END_SRC
